{
  "ver": "1.0.23",
  "uuid": "8e146ec3-81d6-4894-82b2-4cf39398a0ec",
  "compiledShaders": [
    {
      "glsl1": {
        "vert": "\nprecision highp float;\nuniform mat4 cc_matViewProj;\nuniform mat4 cc_matWorld;\n\nattribute vec3 a_position;\nattribute vec4 a_color;\nvarying vec4 v_color;\n\n#if USE_TEXTURE\nattribute vec2 a_uv0;\nvarying vec2 v_uv0;\n#endif\n\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n\n  v_color = a_color;\n\n  gl_Position = pos;\n}\n",
        "frag": "\nprecision highp float;\n\n#if USE_ALPHA_TEST\n  \n  uniform float alphaThreshold;\n#endif\n\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\n\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\n\nvarying vec4 v_color;\n\nvarying vec2 v_uv0;\nuniform sampler2D texture;\n\nuniform vec2 iResolution;\nuniform float time;\n#define S(x,y,z) smoothstep(x,y,z)\n#define B(x,y,z,w) S(x-z, x+z, w)*S(y+z, y-z, w)\n#define saturate(x) clamp(x,0.,1.)\n\nvec3 hash31(float p) {\n  vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n  p3 += dot(p3, p3.yzx + 19.19);\n  return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nfloat hash12(vec2 p){\n  vec3 p3  = fract(vec3(p.xyx) * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat circ(vec2 uv, vec2 pos, float size) {\n  uv -= pos;\n    \n    size *= size;\n    return S(size*1.1, size, dot(uv, uv));\n}\n\nfloat light(vec2 uv, vec2 pos, float size) {\n  uv -= pos;\n    \n    size *= size;\n    return size/dot(uv, uv);\n}\n\nvec3 explosion(vec2 uv, vec2 p, float seed, float t) {\n  \n    vec3 col = vec3(0.);\n    \n    vec3 en = hash31(seed);\n    vec3 baseCol = en;\n\n    for(float i=0.; i<70.; i++) {\n      vec3 n = hash31(i)-.5;\n      \n      vec2 startP = p-vec2(0., t*t*.1);        \n      vec2 endP = startP+normalize(n.xy)*n.z;\n      float pt = 1.-pow(t-1., 2.);\n      vec2 pos = mix(p, endP, pt);    \n      float size = mix(.01, .005, S(0., .1, pt));\n      size *= S(1., .1, pt);\n      \n      float sparkle = (sin((pt+n.z)*100.)*.5+.5);\n      sparkle = pow(sparkle, pow(en.x, 3.)*50.)*mix(0.01, .01, en.y*n.y);\n\n      size += sparkle*B(en.x, en.y, en.z, t);\n      \n      col += baseCol*light(uv, pos, size);\n    }\n    \n    return col;\n}\n\nvec3 Rainbow(vec3 c) {\n  \n    float t=time;\n    \n    float avg = (c.r+c.g+c.b)/3.;\n    c = avg + (c-avg)*sin(vec3(0., .333, .666)+t);\n    \n    c += sin(vec3(.4, .3, .3)*t + vec3(1.1244,3.43215,6.435))*vec3(.4, .1, .5);\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  vec2 uv = fragCoord.xy / iResolution.xy;\n\n  uv.x -= .5;\n  uv.x *= iResolution.x/iResolution.y;\n  \n  float n = hash12(uv+10.);\n  float t = time*.5;\n  \n  vec3 c = vec3(0.);\n\n  for(float i=0.; i<8.; i++) {\n    float et = t+i*1234.45235;\n    float id = floor(et);\n    et -= id;\n    \n    vec2 p = hash31(id).xy;\n    p.x -= .5;\n    p.x *= 1.6;\n    c += explosion(uv, p, id, et);\n  }\n  c = Rainbow(c);\n  \n  fragColor = vec4(c, 1.);\n}\n\nvoid main () {\n  mainImage(gl_FragColor,v_uv0.xy * iResolution.xy);\n}\n"
      },
      "glsl3": {
        "vert": "\nprecision highp float;\nuniform CCGlobal {\n  vec4 cc_time;\n\n  vec4 cc_screenSize;\n\n  vec4 cc_screenScale;\n\n  vec4 cc_nativeSize;\n\n  mat4 cc_matView;\n  mat4 cc_matViewInv;\n  mat4 cc_matProj;\n  mat4 cc_matProjInv;\n  mat4 cc_matViewProj;\n  mat4 cc_matViewProjInv;\n  vec4 cc_cameraPos;\n\n  vec4 cc_exposure;\n\n  vec4 cc_mainLitDir;\n\n  vec4 cc_mainLitColor;\n\n  vec4 cc_ambientSky;\n  vec4 cc_ambientGround;\n};\nuniform CCLocal {\n  mat4 cc_matWorld;\n  mat4 cc_matWorldIT;\n};\n\nin vec3 a_position;\nin vec4 a_color;\nout vec4 v_color;\n\n#if USE_TEXTURE\nin vec2 a_uv0;\nout vec2 v_uv0;\n#endif\n\nvoid main () {\n  vec4 pos = vec4(a_position, 1);\n\n  #if CC_USE_MODEL\n  pos = cc_matViewProj * cc_matWorld * pos;\n  #else\n  pos = cc_matViewProj * pos;\n  #endif\n\n  #if USE_TEXTURE\n  v_uv0 = a_uv0;\n  #endif\n\n  v_color = a_color;\n\n  gl_Position = pos;\n}\n",
        "frag": "\nprecision highp float;\n\n#if USE_ALPHA_TEST\n  \n  uniform ALPHA_TEST {\n    float alphaThreshold;\n  }\n#endif\n\nvoid ALPHA_TEST (in vec4 color) {\n  #if USE_ALPHA_TEST\n      if (color.a < alphaThreshold) discard;\n  #endif\n}\n\nvoid ALPHA_TEST (in float alpha) {\n  #if USE_ALPHA_TEST\n      if (alpha < alphaThreshold) discard;\n  #endif\n}\n\nin vec4 v_color;\n\nin vec2 v_uv0;\nuniform sampler2D texture;\n\nuniform ARGS {\n  vec2 iResolution;\n  float time;\n}\n\n#define S(x,y,z) smoothstep(x,y,z)\n#define B(x,y,z,w) S(x-z, x+z, w)*S(y+z, y-z, w)\n#define saturate(x) clamp(x,0.,1.)\n\nvec3 hash31(float p) {\n  vec3 p3 = fract(vec3(p) * vec3(.1031,.11369,.13787));\n  p3 += dot(p3, p3.yzx + 19.19);\n  return fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\nfloat hash12(vec2 p){\n  vec3 p3  = fract(vec3(p.xyx) * vec3(.1031,.11369,.13787));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat circ(vec2 uv, vec2 pos, float size) {\n  uv -= pos;\n    \n    size *= size;\n    return S(size*1.1, size, dot(uv, uv));\n}\n\nfloat light(vec2 uv, vec2 pos, float size) {\n  uv -= pos;\n    \n    size *= size;\n    return size/dot(uv, uv);\n}\n\nvec3 explosion(vec2 uv, vec2 p, float seed, float t) {\n  \n    vec3 col = vec3(0.);\n    \n    vec3 en = hash31(seed);\n    vec3 baseCol = en;\n\n    for(float i=0.; i<70.; i++) {\n      vec3 n = hash31(i)-.5;\n      \n      vec2 startP = p-vec2(0., t*t*.1);        \n      vec2 endP = startP+normalize(n.xy)*n.z;\n      float pt = 1.-pow(t-1., 2.);\n      vec2 pos = mix(p, endP, pt);    \n      float size = mix(.01, .005, S(0., .1, pt));\n      size *= S(1., .1, pt);\n      \n      float sparkle = (sin((pt+n.z)*100.)*.5+.5);\n      sparkle = pow(sparkle, pow(en.x, 3.)*50.)*mix(0.01, .01, en.y*n.y);\n\n      size += sparkle*B(en.x, en.y, en.z, t);\n      \n      col += baseCol*light(uv, pos, size);\n    }\n    \n    return col;\n}\n\nvec3 Rainbow(vec3 c) {\n  \n    float t=time;\n    \n    float avg = (c.r+c.g+c.b)/3.;\n    c = avg + (c-avg)*sin(vec3(0., .333, .666)+t);\n    \n    c += sin(vec3(.4, .3, .3)*t + vec3(1.1244,3.43215,6.435))*vec3(.4, .1, .5);\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n  vec2 uv = fragCoord.xy / iResolution.xy;\n\n  uv.x -= .5;\n  uv.x *= iResolution.x/iResolution.y;\n  \n  float n = hash12(uv+10.);\n  float t = time*.5;\n  \n  vec3 c = vec3(0.);\n\n  for(float i=0.; i<8.; i++) {\n    float et = t+i*1234.45235;\n    float id = floor(et);\n    et -= id;\n    \n    vec2 p = hash31(id).xy;\n    p.x -= .5;\n    p.x *= 1.6;\n    c += explosion(uv, p, id, et);\n  }\n  c = Rainbow(c);\n  \n  fragColor = vec4(c, 1.);\n}\n\nvoid main () {\n  mainImage(gl_FragColor,v_uv0.xy * iResolution.xy);\n}\n"
      }
    }
  ],
  "subMetas": {}
}